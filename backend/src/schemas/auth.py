from collections.abc import Callable
from typing import (
    ClassVar,
    Final,
    Literal,
    TypedDict,
    cast,
)

from pydantic import BaseModel, EmailStr, Field, field_validator

from src.utils.validation import get_password_validation_error, validate_email

# Constants
TOKEN_TYPE_BEARER: Final[Literal["bearer"]] = "bearer"


class UserRegisterRequest(BaseModel):
    email: EmailStr
    password: str = Field(..., min_length=8, max_length=128)
    name: str | None = Field(None, max_length=128)

    # Type for validator signatures
    _email_validator: ClassVar[Callable[[type["UserRegisterRequest"], str], str]]
    _password_validator: ClassVar[Callable[[type["UserRegisterRequest"], str], str]]

    # __annotations__ is automatically generated by Python and Pydantic; explicit assignment is not required and can cause type errors.

    @field_validator("email")
    @classmethod
    def validate_email_field(cls: type["UserRegisterRequest"], v: str) -> str:
        """
        Validates the email field.
        Raises:
            ValueError: If the email format is invalid.
        """
        if not validate_email(v):
            raise ValueError("Invalid email format.")
        return v

    @field_validator("password")
    @classmethod
    def validate_password_field(cls: type["UserRegisterRequest"], v: str) -> str:
        """
        Validates the password field.
        Raises:
            ValueError: If the password does not meet requirements.
        """
        err: str | None = get_password_validation_error(v)
        if err:
            raise ValueError(err)
        return v


class UserLoginRequest(BaseModel):
    email: EmailStr
    password: str

    # __annotations__ is automatically generated by Python and Pydantic; explicit assignment is not required and can cause type errors.


class PasswordResetRequest(BaseModel):
    email: EmailStr
    _email_validator: ClassVar[Callable[[type["PasswordResetRequest"], str], str]]

    # __annotations__ is automatically generated by Python and Pydantic; explicit assignment is not required and can cause type errors.

    @field_validator("email")
    @classmethod
    def validate_email_field(cls: type["PasswordResetRequest"], v: str) -> str:
        """
        Validates the email field for password reset.
        Raises:
            ValueError: If the email format is invalid.
        """
        if not validate_email(v):
            raise ValueError("Invalid email format.")
        return v


class PasswordResetConfirmRequest(BaseModel):
    token: str
    new_password: str = Field(..., min_length=8, max_length=128)
    _password_validator: ClassVar[
        Callable[[type["PasswordResetConfirmRequest"], str], str]
    ]

    # __annotations__ is automatically generated by Python and Pydantic; explicit assignment is not required and can cause type errors.

    @field_validator("new_password")
    @classmethod
    def validate_password_field(
        cls: type["PasswordResetConfirmRequest"], v: str
    ) -> str:
        """
        Validates the new password field for password reset confirmation.
        Raises:
            ValueError: If the password does not meet requirements.
        """
        err: str | None = get_password_validation_error(v)
        if err:
            raise ValueError(err)
        return v


# TypedDict for AuthResponse structure


class AuthResponseDict(TypedDict):
    access_token: str
    refresh_token: str
    token_type: Literal["bearer"]


class AuthResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: Literal["bearer"] = TOKEN_TYPE_BEARER

    # __annotations__ is automatically generated by Python and Pydantic; explicit assignment is not required and can cause type errors.


class MessageResponseDict(TypedDict):
    message: str


class MessageResponse(BaseModel):
    message: str

    # __annotations__ is automatically generated by Python and Pydantic; explicit assignment is not required and can cause type errors.
