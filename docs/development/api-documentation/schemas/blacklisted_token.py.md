# Blacklisted Token Schema Documentation

## Purpose

The `blacklisted_token.py` schema module defines Pydantic data validation models for JWT token blacklist management in the ReViewPoint application. This schema provides structured validation, serialization, and type safety for token security operations, ensuring consistent token revocation and blacklist management across the authentication and security layers.

## Architecture

The schema follows a focused token security validation pattern:

- **Token Security Layer**: Blacklisted token identification and validation
- **Revocation Management Layer**: Token invalidation and security enforcement
- **Type Safety Layer**: Strong typing with Field validation and constraints
- **ORM Integration Layer**: Seamless SQLAlchemy model conversion for blacklist storage
- **API Serialization Layer**: Optimized JSON responses for security operations
- **Audit Layer**: Token revocation tracking and security monitoring

## Core Schema Class

### `BlacklistedTokenSchema`

Comprehensive blacklisted token representation with validation and security tracking.

```python
# Example usage - Token blacklisting
blacklisted_token = BlacklistedTokenSchema(
    id=12345,
    token="eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
    blacklisted_at=datetime(2024, 7, 23, 14, 30, 0)
)

# Security validation usage
is_blacklisted = await check_token_blacklist(token_string)
```

**Field Specifications:**

**Primary Identification:**

- `id: int` - Unique blacklist entry identifier (primary key)
- `token: str` - Blacklisted token value (full JWT or token hash)

**Security Tracking:**

- `blacklisted_at: datetime` - Timestamp when token was blacklisted

**Field Documentation:**

```python
id: int = Field(..., description="Unique identifier for the blacklisted token entry")
token: str = Field(..., description="The blacklisted token value")
blacklisted_at: datetime = Field(..., description="Timestamp when the token was blacklisted")
```

## Validation Features

### Token Identification

**Token Value Validation:**

```python
token: str = Field(..., description="The blacklisted token value")
```

- **Required Field**: Cannot be null or empty
- **String Type**: Supports full JWT tokens or hashed values
- **Security**: Enables token lookup and validation
- **Flexibility**: Handles various token formats and lengths

**Unique Identification:**

```python
id: int = Field(..., description="Unique identifier for the blacklisted token entry")
```

- **Primary Key**: Unique database identifier
- **Integer Type**: Efficient database indexing
- **Required Field**: Every blacklist entry must have ID
- **Auto-increment**: Typically generated by database

### Temporal Tracking

**Blacklist Timestamp:**

```python
blacklisted_at: datetime = Field(..., description="Timestamp when the token was blacklisted")
```

- **Required Field**: Must track when token was blacklisted
- **DateTime Type**: Precise timestamp with timezone awareness
- **Audit Trail**: Security audit and compliance tracking
- **Cleanup**: Enables automated token cleanup after expiration

### Configuration Features

**ORM Integration:**

```python
model_config = ConfigDict(from_attributes=True)
```

- **SQLAlchemy Compatibility**: Direct conversion from ORM models
- **Attribute Mapping**: Automatic field mapping from database models
- **Performance**: Efficient object conversion
- **Type Safety**: Maintains type integrity during conversion

## Usage Patterns

### Token Blacklisting

```python
async def blacklist_token_endpoint(
    token: str,
    current_user: User = Depends(get_current_user)
):
    try:
        # Create blacklist entry
        blacklist_entry = await blacklist_service.blacklist_token(token)

        # Convert to schema for response
        blacklisted_schema = BlacklistedTokenSchema(
            id=blacklist_entry.id,
            token=blacklist_entry.token,
            blacklisted_at=blacklist_entry.blacklisted_at
        )

        return {
            "message": "Token successfully blacklisted",
            "blacklisted_token": blacklisted_schema
        }

    except Exception as e:
        logger.error(f"Token blacklisting failed: {e}")
        raise HTTPException(
            status_code=500,
            detail="Failed to blacklist token"
        )
```

### Token Validation

```python
async def validate_token_not_blacklisted(token: str) -> bool:
    """Check if token is blacklisted."""
    try:
        # Query blacklist repository
        blacklisted_entry = await blacklist_repository.get_blacklisted_token(token)

        if blacklisted_entry:
            # Convert to schema for logging
            blacklist_schema = BlacklistedTokenSchema(
                id=blacklisted_entry.id,
                token=blacklisted_entry.token,
                blacklisted_at=blacklisted_entry.blacklisted_at
            )

            logger.warning(
                f"Attempted use of blacklisted token: {blacklist_schema.id} "
                f"(blacklisted at {blacklist_schema.blacklisted_at})"
            )
            return False

        return True

    except Exception as e:
        logger.error(f"Token blacklist validation failed: {e}")
        # Fail secure - treat as blacklisted if validation fails
        return False
```

### Logout Implementation

```python
async def logout_endpoint(
    refresh_token_request: RefreshTokenRequest,
    authorization: str = Header(...),
    current_user: User = Depends(get_current_user)
):
    try:
        # Extract access token from header
        access_token = authorization.replace("Bearer ", "")

        # Blacklist both access and refresh tokens
        access_blacklist = await blacklist_service.blacklist_token(access_token)
        refresh_blacklist = await blacklist_service.blacklist_token(
            refresh_token_request.refresh_token
        )

        # Convert to schemas for response
        blacklisted_tokens = [
            BlacklistedTokenSchema(
                id=access_blacklist.id,
                token=access_blacklist.token,
                blacklisted_at=access_blacklist.blacklisted_at
            ),
            BlacklistedTokenSchema(
                id=refresh_blacklist.id,
                token=refresh_blacklist.token,
                blacklisted_at=refresh_blacklist.blacklisted_at
            )
        ]

        return {
            "message": "Successfully logged out",
            "blacklisted_tokens": blacklisted_tokens
        }

    except Exception as e:
        logger.error(f"Logout failed: {e}")
        raise HTTPException(status_code=500, detail="Logout failed")
```

### Blacklist Cleanup

```python
async def cleanup_expired_tokens():
    """Remove expired tokens from blacklist."""
    try:
        # Get current time
        current_time = datetime.utcnow()

        # Calculate expiration threshold (e.g., 30 days)
        expiration_threshold = current_time - timedelta(days=30)

        # Get expired blacklist entries
        expired_entries = await blacklist_repository.get_tokens_blacklisted_before(
            expiration_threshold
        )

        # Convert to schemas for logging
        expired_schemas = [
            BlacklistedTokenSchema(
                id=entry.id,
                token=entry.token,
                blacklisted_at=entry.blacklisted_at
            )
            for entry in expired_entries
        ]

        # Remove expired entries
        for schema in expired_schemas:
            await blacklist_repository.remove_blacklisted_token(schema.id)
            logger.info(
                f"Removed expired blacklisted token {schema.id} "
                f"(blacklisted at {schema.blacklisted_at})"
            )

        return {
            "message": f"Cleaned up {len(expired_schemas)} expired tokens",
            "removed_tokens": len(expired_schemas)
        }

    except Exception as e:
        logger.error(f"Token cleanup failed: {e}")
        raise
```

### Security Audit

```python
async def audit_blacklisted_tokens(
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    limit: int = 100
):
    """Generate security audit report for blacklisted tokens."""
    try:
        # Set default date range if not provided
        if not end_date:
            end_date = datetime.utcnow()
        if not start_date:
            start_date = end_date - timedelta(days=30)

        # Get blacklisted tokens in date range
        blacklisted_entries = await blacklist_repository.get_tokens_blacklisted_between(
            start_date=start_date,
            end_date=end_date,
            limit=limit
        )

        # Convert to schemas for response
        blacklist_schemas = [
            BlacklistedTokenSchema(
                id=entry.id,
                token=entry.token,
                blacklisted_at=entry.blacklisted_at
            )
            for entry in blacklisted_entries
        ]

        # Generate audit statistics
        total_blacklisted = len(blacklist_schemas)
        tokens_by_date = {}

        for schema in blacklist_schemas:
            date_key = schema.blacklisted_at.date().isoformat()
            tokens_by_date[date_key] = tokens_by_date.get(date_key, 0) + 1

        return {
            "audit_period": {
                "start_date": start_date.isoformat(),
                "end_date": end_date.isoformat()
            },
            "total_blacklisted_tokens": total_blacklisted,
            "tokens_by_date": tokens_by_date,
            "blacklisted_tokens": blacklist_schemas[:10]  # First 10 for review
        }

    except Exception as e:
        logger.error(f"Blacklist audit failed: {e}")
        raise HTTPException(
            status_code=500,
            detail="Failed to generate blacklist audit"
        )
```

## Security Considerations

### Token Storage Security

**Secure Token Storage:**

- Tokens can be stored as hashes for security
- Full tokens stored only when necessary for validation
- Database encryption for sensitive token data
- Secure deletion of expired blacklist entries

**Access Control:**

- Blacklist operations require authentication
- Only authorized users can blacklist tokens
- Audit logging for all blacklist operations
- Rate limiting for blacklist endpoints

### Token Validation Security

**Fail-Secure Approach:**

```python
async def secure_token_validation(token: str) -> bool:
    """Fail-secure token blacklist validation."""
    try:
        # Attempt blacklist check
        is_blacklisted = await check_token_blacklist(token)
        return not is_blacklisted
    except DatabaseError:
        # Fail secure - treat as blacklisted on database error
        logger.error("Database error during token validation - failing secure")
        return False
    except Exception as e:
        # Fail secure - treat as blacklisted on any error
        logger.error(f"Token validation error: {e} - failing secure")
        return False
```

**Performance Security:**

- Indexed token lookups for fast blacklist checks
- Caching for frequently checked tokens
- Efficient cleanup of expired entries
- Rate limiting to prevent blacklist flooding

### Audit and Compliance

**Security Auditing:**

- Complete audit trail of all blacklisted tokens
- Timestamp tracking for compliance requirements
- Regular cleanup schedules for expired tokens
- Security event logging and monitoring

**Compliance Features:**

- GDPR-compliant token deletion after expiration
- Audit logs for security compliance
- Data retention policies for blacklist entries
- Security incident response capabilities

## Performance Considerations

### Database Optimization

**Efficient Queries:**

```python
# Optimized blacklist checking
async def check_token_blacklist_optimized(token: str) -> bool:
    """Optimized token blacklist check with caching."""
    # Check cache first
    cached_result = await cache.get(f"blacklist:{hash(token)}")
    if cached_result is not None:
        return cached_result == "blacklisted"

    # Query database
    blacklisted_entry = await blacklist_repository.get_blacklisted_token(token)
    is_blacklisted = blacklisted_entry is not None

    # Cache result for performance
    cache_value = "blacklisted" if is_blacklisted else "valid"
    await cache.set(
        f"blacklist:{hash(token)}",
        cache_value,
        expire=300  # 5 minutes
    )

    return is_blacklisted
```

### Memory Management

**Schema Efficiency:**

- Minimal memory footprint with essential fields only
- Efficient datetime handling
- String optimization for token storage
- Batch processing for bulk operations

### Cleanup Strategies

**Automated Cleanup:**

```python
# Efficient token cleanup strategy
async def automated_token_cleanup():
    """Automated cleanup of expired blacklisted tokens."""
    batch_size = 1000
    cleanup_threshold = datetime.utcnow() - timedelta(days=30)

    while True:
        # Process in batches to avoid memory issues
        expired_tokens = await blacklist_repository.get_expired_tokens_batch(
            threshold=cleanup_threshold,
            limit=batch_size
        )

        if not expired_tokens:
            break

        # Convert to schemas for logging
        schemas = [
            BlacklistedTokenSchema.model_validate(token)
            for token in expired_tokens
        ]

        # Batch delete
        token_ids = [schema.id for schema in schemas]
        await blacklist_repository.delete_tokens_batch(token_ids)

        logger.info(f"Cleaned up {len(schemas)} expired blacklisted tokens")
```

## Error Handling

### Validation Error Patterns

```python
# Blacklist schema validation errors
async def validate_blacklist_entry(token_data: dict) -> BlacklistedTokenSchema:
    try:
        return BlacklistedTokenSchema(**token_data)
    except ValidationError as e:
        # Handle specific validation failures
        for error in e.errors():
            field = error["loc"][-1]
            error_type = error["type"]

            if field == "token" and "missing" in error_type:
                raise HTTPException(
                    status_code=400,
                    detail="Token value is required for blacklisting"
                )
            elif field == "blacklisted_at" and "datetime_parsing" in error_type:
                raise HTTPException(
                    status_code=400,
                    detail="Invalid blacklist timestamp format"
                )

        # Generic validation error
        raise HTTPException(
            status_code=400,
            detail="Invalid blacklist entry data"
        )
```

### Database Error Handling

```python
# Database operation error handling
async def safe_token_blacklisting(token: str) -> BlacklistedTokenSchema:
    try:
        # Attempt to blacklist token
        blacklist_entry = await blacklist_repository.create_blacklist_entry(token)
        return BlacklistedTokenSchema.model_validate(blacklist_entry)

    except IntegrityError:
        # Token already blacklisted
        existing_entry = await blacklist_repository.get_blacklisted_token(token)
        if existing_entry:
            return BlacklistedTokenSchema.model_validate(existing_entry)
        raise HTTPException(
            status_code=409,
            detail="Token already blacklisted"
        )

    except DatabaseError as e:
        logger.error(f"Database error during token blacklisting: {e}")
        raise HTTPException(
            status_code=500,
            detail="Failed to blacklist token due to database error"
        )
```

## Best Practices

### Schema Design

- **Security Focus**: Schema designed with security as primary concern
- **Minimal Data**: Only essential fields for token blacklisting
- **Type Safety**: Strong typing throughout blacklist operations
- **Audit Support**: Fields support comprehensive audit trails
- **Performance**: Optimized for frequent blacklist checks

### Token Management

- **Immediate Blacklisting**: Tokens blacklisted immediately upon logout/revocation
- **Cleanup Automation**: Regular cleanup of expired blacklist entries
- **Fail-Secure**: Security operations fail securely on errors
- **Audit Logging**: Comprehensive logging of all blacklist operations
- **Performance**: Efficient blacklist checking with caching

### Security Operations

- **Access Control**: Proper authentication for blacklist operations
- **Rate Limiting**: Protection against blacklist flooding attacks
- **Monitoring**: Security monitoring and alerting for blacklist operations
- **Compliance**: Support for regulatory compliance requirements

## Testing Strategies

### Unit Testing

```python
def test_blacklisted_token_schema_creation():
    # Test valid blacklisted token schema creation
    token_data = {
        "id": 1,
        "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.test",
        "blacklisted_at": datetime(2024, 1, 1, 12, 0, 0)
    }

    blacklist_schema = BlacklistedTokenSchema(**token_data)
    assert blacklist_schema.id == 1
    assert blacklist_schema.token == token_data["token"]
    assert blacklist_schema.blacklisted_at == token_data["blacklisted_at"]

def test_blacklist_schema_validation():
    # Test required field validation
    with pytest.raises(ValidationError):
        BlacklistedTokenSchema(
            id=1,
            blacklisted_at=datetime.now()
            # Missing token field
        )

    # Test datetime validation
    with pytest.raises(ValidationError):
        BlacklistedTokenSchema(
            id=1,
            token="test_token",
            blacklisted_at="invalid_date"
        )
```

### Integration Testing

```python
async def test_token_blacklist_flow():
    # Test complete token blacklist workflow
    client = TestClient(app)

    # Login to get tokens
    login_response = client.post("/auth/login", json={
        "email": "test@example.com",
        "password": "testpass"
    })

    tokens = login_response.json()
    access_token = tokens["access_token"]

    # Blacklist token (logout)
    logout_response = client.post(
        "/auth/logout",
        json={"refresh_token": tokens["refresh_token"]},
        headers={"Authorization": f"Bearer {access_token}"}
    )

    assert logout_response.status_code == 200

    # Verify token is blacklisted
    protected_response = client.get(
        "/users/me",
        headers={"Authorization": f"Bearer {access_token}"}
    )

    assert protected_response.status_code == 401
```

### Security Testing

```python
async def test_blacklist_security():
    # Test blacklist validation security
    malicious_token = "malicious.token.value"

    # Should fail securely on invalid token
    is_valid = await validate_token_not_blacklisted(malicious_token)
    assert is_valid is False  # Fail secure

    # Test blacklist entry creation
    blacklist_entry = await blacklist_service.blacklist_token(malicious_token)
    blacklist_schema = BlacklistedTokenSchema.model_validate(blacklist_entry)

    # Verify token is properly blacklisted
    assert blacklist_schema.token == malicious_token
    assert isinstance(blacklist_schema.blacklisted_at, datetime)
```

## Related Files

### Dependencies

- `datetime` - Timestamp handling for blacklist tracking
- `pydantic` - Schema validation framework with Field and ConfigDict
- `typing` - Type annotations for schema fields

### Model Integration

- `src.models.blacklisted_token` - BlacklistedToken SQLAlchemy ORM model
- `src.repositories.blacklisted_token` - Blacklist data access layer
- `src.services.auth` - Authentication service with blacklist integration

### Security Integration

- `src.core.security` - JWT token utilities and validation
- `src.api.deps` - Authentication dependencies with blacklist checking
- `src.api.v1.auth` - Authentication endpoints with logout functionality

## Configuration

### Blacklist Settings

```python
# Blacklist configuration
BLACKLIST_CONFIG = {
    "cleanup_interval_hours": 24,
    "token_retention_days": 30,
    "cache_expire_minutes": 5,
    "batch_size": 1000
}
```

### Security Settings

```python
# Security configuration for blacklist
BLACKLIST_SECURITY = {
    "fail_secure": True,
    "audit_logging": True,
    "rate_limit_requests": 100,
    "rate_limit_window": 3600  # 1 hour
}
```

### Performance Settings

```python
# Performance optimization settings
BLACKLIST_PERFORMANCE = {
    "enable_caching": True,
    "cache_ttl_seconds": 300,
    "max_batch_size": 1000,
    "query_timeout_seconds": 30
}
```

This blacklisted token schema module provides a secure, efficient foundation for JWT token revocation and blacklist management in the ReViewPoint application, ensuring proper security enforcement, audit capabilities, and performance optimization through well-designed Pydantic validation patterns.
