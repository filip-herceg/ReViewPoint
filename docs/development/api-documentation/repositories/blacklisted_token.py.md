# Blacklisted Token Repository Documentation

## Purpose

The `blacklisted_token.py` repository module provides secure token management functionality for JWT token blacklisting in the ReViewPoint application. This repository implements a robust token invalidation system that prevents the reuse of revoked or logged-out tokens, ensuring security and session management integrity.

## Architecture

The repository follows a focused security-first design pattern:

- **Security Layer**: JWT token invalidation and blacklist management
- **Data Persistence Layer**: SQLAlchemy async ORM for blacklist storage
- **Validation Layer**: Token expiration and validity checking
- **Performance Layer**: Efficient token lookup with proper indexing

## Core Functions

### Token Blacklisting Operations

#### `blacklist_token(session, jti, expires_at)`

Adds a JWT token to the blacklist to prevent future use.

```python
# Example usage
from datetime import datetime, UTC, timedelta

# Blacklist a token when user logs out
jti = "unique-jwt-id-12345"
expires_at = datetime.now(UTC) + timedelta(hours=24)

await blacklist_token(session, jti, expires_at)
await session.commit()  # Caller controls transaction
```

**Parameters:**

- `session` (AsyncSession): Database session for persistence
- `jti` (str): JWT ID (unique identifier for the token)
- `expires_at` (datetime): Token expiration timestamp

**Features:**

- **Transaction Control**: Does not commit, allowing caller to control transaction boundaries
- **Immutable Records**: Once blacklisted, tokens cannot be un-blacklisted
- **Expiration Tracking**: Stores token expiration for automatic cleanup
- **Type Safety**: Strong typing with Final annotations

### Token Validation Operations

#### `is_token_blacklisted(session, jti)`

Checks if a JWT token is blacklisted and still valid (not expired).

```python
# Example usage
jti = "unique-jwt-id-12345"
is_blacklisted = await is_token_blacklisted(session, jti)

if is_blacklisted:
    # Token is blacklisted and not expired - reject request
    raise HTTPException(status_code=401, detail="Token has been revoked")
else:
    # Token is either not blacklisted or has expired - allow if valid
    proceed_with_request()
```

**Return Value:**

- `bool`: True if token is blacklisted and not expired, False otherwise

**Validation Logic:**

1. **Database Lookup**: Searches for token by JTI
2. **Existence Check**: Returns False if token not found in blacklist
3. **Expiration Validation**: Checks if token has expired
4. **Timezone Handling**: Properly handles naive and timezone-aware datetimes
5. **Security Decision**: Returns True only if blacklisted AND not expired

## Security Implementation

### JWT Token Security

**Token Identification:**

```python
# JTI (JWT ID) serves as unique token identifier
jti = "unique-jwt-id-12345"  # Generated by JWT library
```

**Expiration Handling:**

```python
# Proper timezone handling for security
now = datetime.now(UTC)
if expires_at.tzinfo is None:
    expires_at = expires_at.replace(tzinfo=UTC)
if expires_at > now:
    return True  # Token is blacklisted and valid
```

### Database Security

**Model Structure:**

```python
class BlacklistedToken:
    id: int                    # Primary key
    jti: str                  # JWT ID (unique)
    expires_at: datetime      # Token expiration
    created_at: datetime      # Blacklist timestamp
```

**Query Patterns:**

```python
# Efficient token lookup by JTI
select(BlacklistedToken).where(BlacklistedToken.jti == jti)
```

## Usage Patterns

### User Logout Workflow

```python
async def logout_user(session: AsyncSession, access_token: str, refresh_token: str):
    """Complete logout workflow with token blacklisting."""

    # 1. Decode tokens to get JTIs
    access_jti = decode_jwt_jti(access_token)
    refresh_jti = decode_jwt_jti(refresh_token)

    # 2. Get token expiration times
    access_expires = decode_jwt_expiration(access_token)
    refresh_expires = decode_jwt_expiration(refresh_token)

    # 3. Blacklist both tokens
    await blacklist_token(session, access_jti, access_expires)
    await blacklist_token(session, refresh_jti, refresh_expires)

    # 4. Commit transaction
    await session.commit()

    return {"message": "Successfully logged out"}
```

### Token Validation Middleware

```python
async def validate_token_middleware(request: Request, call_next):
    """Middleware to check token blacklist status."""

    # 1. Extract token from request
    token = extract_token_from_request(request)
    if not token:
        return await call_next(request)

    # 2. Get JTI from token
    try:
        jti = decode_jwt_jti(token)
    except InvalidTokenError:
        return await call_next(request)

    # 3. Check blacklist status
    async with get_session() as session:
        is_blacklisted = await is_token_blacklisted(session, jti)

    if is_blacklisted:
        return JSONResponse(
            status_code=401,
            content={"detail": "Token has been revoked"}
        )

    return await call_next(request)
```

### Admin Token Revocation

```python
async def revoke_user_tokens(session: AsyncSession, user_id: int):
    """Admin function to revoke all tokens for a user."""

    # 1. Get all active tokens for user (from auth service)
    active_tokens = await get_user_active_tokens(user_id)

    # 2. Blacklist each token
    for token_data in active_tokens:
        await blacklist_token(
            session=session,
            jti=token_data["jti"],
            expires_at=token_data["expires_at"]
        )

    await session.commit()

    return {"revoked_tokens": len(active_tokens)}
```

## Performance Considerations

### Database Optimization

**Indexing Strategy:**

```sql
-- Primary key index
CREATE INDEX pk_blacklisted_tokens ON blacklisted_tokens(id);

-- JTI lookup index (most important)
CREATE UNIQUE INDEX idx_blacklisted_tokens_jti ON blacklisted_tokens(jti);

-- Expiration cleanup index
CREATE INDEX idx_blacklisted_tokens_expires_at ON blacklisted_tokens(expires_at);
```

**Query Performance:**

- **JTI Lookup**: O(log n) with B-tree index
- **Minimal Data Transfer**: Only fetch required fields
- **Efficient Filtering**: Database-level expiration checking

### Memory Management

**Cleanup Strategy:**

```python
async def cleanup_expired_tokens(session: AsyncSession):
    """Remove expired tokens from blacklist."""
    from sqlalchemy import delete

    now = datetime.now(UTC)
    stmt = delete(BlacklistedToken).where(BlacklistedToken.expires_at <= now)
    await session.execute(stmt)
    await session.commit()
```

**Scheduled Cleanup:**

```python
# Run cleanup periodically (e.g., daily)
@scheduler.scheduled_job("cron", hour=2)  # 2 AM daily
async def daily_token_cleanup():
    async with get_session() as session:
        await cleanup_expired_tokens(session)
```

## Error Handling

### Token Validation Errors

```python
try:
    is_blacklisted = await is_token_blacklisted(session, jti)
except Exception as e:
    # Log error but don't block request if blacklist check fails
    logger.error(f"Blacklist check failed for JTI {jti}: {e}")
    # Fail safe: assume not blacklisted to avoid blocking valid users
    is_blacklisted = False
```

### Database Operation Errors

```python
try:
    await blacklist_token(session, jti, expires_at)
    await session.commit()
except Exception as e:
    await session.rollback()
    logger.error(f"Failed to blacklist token {jti}: {e}")
    raise HTTPException(status_code=500, detail="Logout failed")
```

## Security Considerations

### Attack Prevention

**Token Replay Protection:**

- Blacklisted tokens cannot be reused even if stolen
- Immediate token invalidation on logout
- Protection against session hijacking

**Brute Force Mitigation:**

- Efficient database lookups prevent DoS attacks
- Indexed JTI lookups for performance
- Automatic expired token cleanup

### Data Privacy

**Minimal Data Storage:**

- Only stores JTI and expiration (no sensitive data)
- Automatic cleanup of expired records
- No personal information in blacklist

**Compliance Features:**

- GDPR-compliant data retention
- Automatic data purging
- Audit trail through timestamps

## Testing Strategies

### Unit Testing

```python
async def test_blacklist_token():
    # Test token blacklisting
    jti = "test-jti-12345"
    expires_at = datetime.now(UTC) + timedelta(hours=1)

    await blacklist_token(session, jti, expires_at)
    await session.commit()

    # Verify token is blacklisted
    is_blacklisted = await is_token_blacklisted(session, jti)
    assert is_blacklisted is True
```

### Integration Testing

```python
async def test_token_expiration():
    # Test expired token handling
    jti = "expired-jti-12345"
    expires_at = datetime.now(UTC) - timedelta(hours=1)  # Expired

    await blacklist_token(session, jti, expires_at)
    await session.commit()

    # Expired tokens should not be considered blacklisted
    is_blacklisted = await is_token_blacklisted(session, jti)
    assert is_blacklisted is False
```

### Security Testing

```python
async def test_timezone_handling():
    # Test timezone edge cases
    jti = "timezone-test-jti"

    # Test naive datetime (should be treated as UTC)
    naive_expires = datetime.now() + timedelta(hours=1)
    await blacklist_token(session, jti, naive_expires)

    is_blacklisted = await is_token_blacklisted(session, jti)
    assert is_blacklisted is True
```

## Related Files

### Dependencies

- `src/models/blacklisted_token.py` - BlacklistedToken SQLAlchemy model
- `datetime` - Timestamp handling with UTC support
- `typing` - Type annotations with Final
- `sqlalchemy` - Database ORM and async operations

### Security Integration

- `src/core/security.py` - JWT token handling utilities
- `src/api/v1/auth.py` - Authentication endpoints
- `src/middleware/auth.py` - Token validation middleware

### Model Relationships

- Independent model (no foreign key relationships)
- Used by authentication system
- Referenced by token validation logic

## Configuration

### Database Settings

```python
# Blacklist table configuration
BLACKLIST_TABLE_NAME = "blacklisted_tokens"
JTI_INDEX_NAME = "idx_blacklisted_tokens_jti"
CLEANUP_BATCH_SIZE = 1000
```

### Cleanup Settings

```python
# Token cleanup configuration
CLEANUP_SCHEDULE = "0 2 * * *"  # Daily at 2 AM
EXPIRED_TOKEN_RETENTION_DAYS = 0  # Remove immediately
CLEANUP_BATCH_SIZE = 1000
```

### Performance Settings

```python
# Query optimization settings
MAX_BLACKLIST_SIZE = 1000000  # Alert threshold
INDEX_REBUILD_THRESHOLD = 100000  # Maintenance threshold
QUERY_TIMEOUT_SECONDS = 5
```

## Module Exports

```python
# Main functions exported by module
__all__ = [
    "blacklist_token",
    "is_token_blacklisted",
]
```

This blacklisted token repository provides a secure, efficient foundation for JWT token management in the ReViewPoint application, ensuring proper session invalidation and protection against token-based security attacks through well-designed repository patterns and proper database abstraction.
